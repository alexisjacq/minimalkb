#!/usr/bin/env python
# -*- coding: utf-8 -*-

__version__="0.3.0"

import logging; logger = logging.getLogger("minimalKB");


import sys
import asyncore, asynchat
import os, socket, string
import traceback

import json

from minimalkb.kb import MinimalKB, KbServerError

PORT = 6969

class MinimalKBChannel(asynchat.async_chat):

    def __init__(self, server, sock, addr, kb):
        asynchat.async_chat.__init__(self, sock)
        self.set_terminator("#end#")
        self.request = None
        self.data = ""

        self.kb = kb

    def parse_request(self, req):
        tokens = [a.strip() for a in req.strip().split("\n")]
        if len(tokens) == 1:
            return tokens[0], []
        else:
            args = []
            for t in tokens[1:]:
                try:
                    args.append(json.loads(t))
                except ValueError:
                    logger.error("Invalid arguments for <%s>: %s. Valid JSON was expected."%(tokens[0], t))
            return tokens[0], args

    def collect_incoming_data(self, data):
        self.data = self.data + data

    def found_terminator(self):

        res, events = None, None
        logger.debug("Got request:" + self.data )
        request, args = self.parse_request(self.data)
        self.data = ""
        try:
            res = self.kb.execute(request, *args)
        except Exception as e:
            if logger.level == logging.DEBUG:
                traceback.print_exc()
            logger.error("Request failed: %s" % e)
            self.push("error\n")
            self.push("KbError\n")
            self.push(str(e) + "\n")
            self.push("#end#\n")
            return

        logger.debug("Returned " + str(res))
        self.push("ok\n")
        if res is not None:
            self.push(json.dumps(res))
        self.push("\n#end#\n")

        for e in self.kb.triggered_evts:
            logger.debug("Notifying event %s" % e.id)
            self.push("event\n")
            self.push(e.id + "\n")
            self.push(json.dumps(e.content))
            self.push("\n#end#\n")
        self.kb.triggered_evts = []


class MinimalKBServer(asyncore.dispatcher):

    def __init__(self, port, kb):
        asyncore.dispatcher.__init__(self)

        self.kb = kb

        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.set_reuse_addr()
        self.bind(("", port))
        self.listen(5)

    def handle_accept(self):
        conn, addr = self.accept()
        MinimalKBChannel(self, conn, addr, kb)

def version():
    print("minimalKB %s" % __version__)

if __name__ == '__main__':

    from minimalkb.ansistrm import ColorizingStreamHandler
    import argparse

    parser = argparse.ArgumentParser(description='A minimal knowledge base for robots.')
    parser.add_argument('-v', '--version', action='version',
                       version=version(), help='returns minimalKB version')
    parser.add_argument('-d', '--debug', action='store_true',
                                help='enables verbose output')
    parser.add_argument('ontology', default="", nargs='?', help="local file or URL of an intial ontology to load")

    args = parser.parse_args()

    console = ColorizingStreamHandler()
    
    if args.debug:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    formatter = logging.Formatter('%(asctime)-15s: %(message)s')
    console.setFormatter(formatter)
    logger.addHandler(console)

    kb = MinimalKB(args.ontology)

    s = MinimalKBServer(PORT, kb)
    logger.info("Starting to serve at port %d..." % PORT)
    asyncore.loop()
